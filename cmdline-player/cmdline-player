#!/bin/bash
# Info from:
# https://serverfault.com/questions/178457/can-i-send-some-text-to-the-stdin-of-an-active-process-running-in-a-screen-sessi
# Playback commands using screen's 'stuff' command.

FILE=
WAITING=
PID=
VIDEO="screencast.gif"

main() {

  parse_options "$@" || return

  kill_old_gnu_screencasts
  choose_recording_window # <- using xwininfo
  start_gnu_screen
  start_recording &

  OLDWAITING="$WAITING"

  while read -r line; do
    [[ $line == "screencast paste" ]] && {
      paste=true
      continue
    }
    [[ $line == "screencast subshell" ]] && {
      subshell=true
      continue
    }
    [[ $line == "screencast prompt"* ]] && {
      promptlist="${line##* }"
      waitforprompt=true
      continue
    }
    [[ $line == "screencast firstps" ]] && {
      WAITING="$OLDWAITING"
      continue
    }

    if [[ -n $paste ]]; then
      paste_line "$line"
      [[ -n $subshell ]] && {
        unset subshell
        sleep 1
        WAITING=$(fingerprint)
      }
      unset paste
    else
      print_line "$line"
      [[ -n $subshell ]] && {
        unset subshell
        sleep 1
        WAITING=$(fingerprint)
      }
    fi

    cmd="${line%% *}"

    if [[ $cmd == '#' ]]; then
      sleep 0.5
      continue
    else
      if [[ -n $waitforprompt ]]; then
        unset waitforprompt
        while true; do
          sleep 1
          screen -S screencast -p 0 -X hardcopy latest.hardcopy
          if prompt_found "$promptlist"; then break; fi
        done
        sleep 1
      else
        while [[ $WAITING != $(fingerprint) ]]; do
          sleep 1
        done
        sleep 1
      fi
    fi

  done <"$FILE"

  sleep 2
  end_recording
}

prompt_found() {
  promptlist="$1"
  lastcharinfile=$(grep -v '^$' latest.hardcopy | tail -n 1 | grep -o '.$')
  [[ $promptlist == *"$lastcharinfile"* ]] && return 0
  return 1
}

kill_old_gnu_screencasts() {
  local pid
  while true; do
    pid=$(screen -ls | grep screencast | sed -r 's/[ \t]+//g' | cut -f 1 -d.)
    [[ -z $pid ]] && break
    screen -XS "$pid" quit
  done
}

choose_recording_window() {
  printf 'Click on the window to be recorded\n'
  eval "$(awk 'BEGIN  {X=0;Y=0;} /Abs.*left X/ {X=$NF;} /Abs.*left Y/ {Y=$NF;} /Width/ {W=$NF;} /Height/ {H=$NF;} END { printf "X=%d\nY=%d\nW=%d\nH=%d\n",X,Y,W,H; }' <<<"$(xwininfo)")"
}

start_recording() {
  [[ -e $VIDEO ]] && rm "$VIDEO"
  byzanz-record -d 1200 --x="$X" --y="$Y" --width="$W" --height="$H" "$VIDEO"
}

end_recording() {
  killall byzanz-record &>/dev/null
}

paste_line() {
  screen -S screencast -p 0 -X stuff "$1^M"
  sleep 1
}

print_line() {
  local chararray int
  readarray -t chararray <<<"$(printf '%s' "$1" | grep -o .)"
  for int in "${chararray[@]}"; do
    screen -S screencast -p 0 -X stuff "$int"
    sleep ."$(printf '%02d' $((RANDOM % 16)))"
  done
  sleep .3
  screen -S screencast -p 0 -X stuff "^M"
  sleep .8
}

parse_options() {
  [[ -z $1 ]] && {
    printf 'Usage: %s <FILENAME>\n' "$(basename "$0")"
    return 1
  }

  FILE="$1"
}

start_gnu_screen() {
  printf 'Starting a screen session\n'

  screen -d -m -S screencast zsh
  PID=$(screen -ls | grep screencast | sed -r 's/[ \t]+//g' | cut -f 1 -d.)
  sleep 2
  WAITING=$(fingerprint)

  cat <<EnD
In another terminal type:

  screen -r screencast

Then press 'enter' here and the screencast will start
in the other terminal.
EnD

  printf '>'
  read -r
}

fingerprint() {
  pstree "$PID" | tr -d 0-9 | md5sum
}

# Calls main() if we're called from the command line
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  main "$@"
fi

# vim:ft=sh:sw=2:et:ts=2:
