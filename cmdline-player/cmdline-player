#!/bin/bash
# Info from:
# https://serverfault.com/questions/178457/can-i-send-some-text-to-the-stdin-of-an-active-process-running-in-a-screen-sessi
# Playback commands using screen's 'stuff' command.

DELAY=18 # not <-- less than 1
FILE=
WAITING=
PID=
VIDEO="screencast.gif"

main() {

  parse_options "$@" || return

  kill_old_gnu_screencasts
  choose_recording_window # <- using xwininfo
  start_gnu_screen
  start_recording &

  OLDWAITING="$WAITING"

  pause=0
  linenum=0
  while true; do
    ((linenum++))
    while read -r line; do
      ((linenum++))
      [[ $line == "screencast clear" ]] && {
        screen -S screencast -p 0 -X stuff "clear^M"
        continue
      }
      [[ $line == "screencast delay"* ]] && {
        DELAY="${line##* }"
        continue
      }
      [[ $line == "screencast pause" ]] && {
        printf -- '\n- PAUSED - press any key to unpause...\n'
        pause=1
        break
      }
      [[ $line == '"'* ]] && {
        continue
      }
      [[ $line == "screencast paste" ]] && {
        paste=true
        continue
      }
      [[ $line == "screencast sleep"* ]] && {
        sleep "${line##* }"
        continue
      }
      [[ $line == "screencast subshell" ]] && {
        unset waitforprompt
        subshell=true
        continue
      }
      [[ $line == "screencast prompt"* ]] && {
        promptlist="${line##* }"
        waitforprompt=true
        continue
      }
      [[ $line == "screencast firstps" ]] && {
        unset waitforprompt
        WAITING="$OLDWAITING"
        continue
      }

      if [[ -n $paste ]]; then
        paste_line "$line"
        [[ -n $subshell ]] && {
          unset subshell
          sleep .5
          WAITING=$(fingerprint)
        }
        unset paste
      else
        print_line "$line"
        [[ -n $subshell ]] && {
          unset subshell
          sleep .5
          WAITING=$(fingerprint)
        }
      fi

      cmd="${line%% *}"

      if [[ $cmd == '#' ]]; then
        sleep 0.5
        continue
      else
        if [[ -n $waitforprompt ]]; then
          while true; do
            sleep 1
            screen -S screencast -p 0 -X hardcopy latest.hardcopy
            if prompt_found "$promptlist"; then break; fi
          done
          sleep .5
        else
          while [[ $WAITING != $(fingerprint) ]]; do
            sleep 1
          done
          sleep .5
        fi
      fi

    done <<<"$(sed -n ' '"$linenum"',$ {p}' "$FILE")"
    [[ $pause -eq 1 ]] && {
      read -r
      pause=0
      continue
    }
    break
  done

  sleep 4
  end_recording
  echo
}

prompt_found() {
  promptlist="$1"
  lastcharinfile=$(grep -v '^$' latest.hardcopy | tail -n 1 | grep -o '. *$')
  [[ $promptlist == *"$lastcharinfile"* && -n $lastcharinfile ]] && return 0
  return 1
}

kill_old_gnu_screencasts() {
  local pid
  while true; do
    pid=$(screen -ls | grep screencast | sed -r 's/[ \t]+//g' | cut -f 1 -d.)
    [[ -z $pid ]] && break
    screen -XS "$pid" quit
  done
}

choose_recording_window() {
  printf 'Click on the window to be recorded\n'
  eval "$(awk 'BEGIN  {X=0;Y=0;} /Abs.*left X/ {X=$NF;} /Abs.*left Y/ {Y=$NF;} /Width/ {W=$NF;} /Height/ {H=$NF;} END { printf "X=%d\nY=%d\nW=%d\nH=%d\n",X,Y,W,H; }' <<<"$(xwininfo)")"
}

start_recording() {
  [[ -e $VIDEO ]] && rm "$VIDEO"
  byzanz-record -d 1200 --x="$X" --y="$Y" --width="$W" --height="$H" "$VIDEO"
}

end_recording() {
  killall byzanz-record &>/dev/null
}

paste_line() {
  screen -S screencast -p 0 -X stuff "$1^M"
  sleep .5
}

print_line() {
  local chararray char
  readarray -t chararray <<<"$(printf '%s' "$1" | grep -o .)"
  for char in "${chararray[@]}"; do
    [[ $char == '^' ]] && {
      controlchar=yes
      continue
    }
    if [[ -n $controlchar ]]; then
      #screen -S screencast -p 0 -X stuff "\^c"
      screen -S screencast -p 0 -X stuff "^$char"
    elif [[ $char == \\ ]]; then
      screen -S screencast -p 0 -X stuff \\\\
    else
      screen -S screencast -p 0 -X stuff "$char"
    fi
    sleep ."$(printf '%02d' $((RANDOM % DELAY)))"
  done
  sleep .3
  [[ -z $controlchar ]] && {
    screen -S screencast -p 0 -X stuff "^M"
  }
  controlchar=
  sleep .2
}

parse_options() {
  [[ -z $1 ]] && {
    printf 'Usage: %s <FILENAME>\n' "$(basename "$0")"
    return 1
  }

  FILE="$1"
}

start_gnu_screen() {
  printf 'Starting a screen session\n'

  screen -d -m -S screencast
  PID=$(screen -ls | grep screencast | sed -r 's/[ \t]+//g' | cut -f 1 -d.)
  sleep 2
  WAITING=$(fingerprint)

  cat <<EnD
In another terminal type:

  screen -r screencast

Then press 'enter' here and the screencast will start
in the other terminal.
EnD

  printf '>'
  read -r
}

fingerprint() {
  pstree "$PID" | tr -d 0-9 | md5sum
}

# Calls main() if we're called from the command line
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  main "$@"
fi

# vim:ft=sh:sw=2:et:ts=2:
